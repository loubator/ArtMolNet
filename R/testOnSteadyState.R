
testOnSteadyState <- function( nameSimIndiv, NodeToEval, timeMaxi) {
  setwd(gsub("/tmp","",getwd()))
  setwd(paste(getwd(),"/tmp/",sep=""))
  getwd()
  # ====== Detect for all the nodes if they reach the steady state ====== #
  # == at the end of MaBoSS simulation. Use the files generated by MaBoSS == #
  # == Indicates if it need more time == #
  nameFolder<-list.files(getwd(),pattern = nameSimIndiv )
  nameFolder<-nameFolder[-grep("cfg",nameFolder)]
  #nameFolder <-paste(getwd(),"/tmp/",sep = "")
  #nameFile <- paste(nameFolder, gsub("\\.cfg","", dest_file), "_probtraj_table.csv", sep="")
  nameFile <-paste(nameFolder, "_probtraj_table.csv", sep="")
  
  dataMB <- read.table(paste(getwd(),nameFolder,nameFile,sep="/"), header = TRUE)
  
  head(dataMB)

  # ====== Reduction of the data frame ====== #
  dataMB <- dataMB[,str_detect(colnames(dataMB), "^[Prob|Time]")]
  colnames(dataMB) <- str_replace(colnames(dataMB), "^Prob.", "")
  names <- colnames(dataMB)
  
# ====== List with indices of each node in the dataMB data frame ====== #
#  species <- model$namesSpecies
  species <- unique(unlist(str_split(colnames(dataMB),"\\.")))
  species <- species[!species%in%c("","Time","TH","nil") ]
  
  indexRO <- list()
  for (node in species){
    indexRO[[node]] <- c()
      
    for (aTransState in names){
      if ((str_detect(aTransState, node)==TRUE)){
        indexRO[[node]] <- c(indexRO[[node]], which(names==aTransState))
      }
    }
  }
    
  
  qtty <- c()
  #cmpValues <- c()
  slopeValues <- c()
  rseValues <- c()
  origines <- c()
  for(node in species) {
    indices <- indexRO[[node]]
    if(is.null(dim(dataMB[,indices])) == TRUE){
      # ====== the node/species does not get any activation during the simulation ====== #
      qtty[[node]] <- dataMB[,indices]
    } else {
      # ====== sum of the probabilites for each time tick ====== #
      qtty[[node]] <- apply(dataMB[,indices], 1, sum)
    }
    
    # ====== Slope and RSE of linear Regression ====== #
    # 1) linear regression on the 20 last values
    time <- dataMB[(dim(dataMB)[1]-20):dim(dataMB)[1],which(colnames(dataMB) == "Time")]
    regLin <- as.vector(lm(qtty[[node]][(length(qtty[[node]])-20):(length(qtty[[node]]))] ~ 
                   time))
      
    # 2) get the slop and the RSE
    slopeValues <- c(slopeValues,regLin$coefficient[2])
    rseValues <- c(rseValues, summary(regLin)$sigma)
    origines <- c(origines, regLin$coefficient[1])
  }
  names(slopeValues)<-species
  names(rseValues)<-species
  names(origines)<-species

  SlopeRSE<-list( origines=origines,slopeValues=slopeValues,rseValues=rseValues)

  return(SlopeRSE)
}  
